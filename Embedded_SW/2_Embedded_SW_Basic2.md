# 임베디드 소프트웨어 개발 기본 day02

날짜: 2026년 1월 27일

## 버스와 메모리

### 버스

- 버스 : 컴퓨터 내부에서 데이터, 주소, 제어 신호를 전달하는 주요 통신 경로
- 종류
    - 데이터 버스
    - 주소 버스
    - 제어 버스
- 3가지 종류를 합쳐서 컴퓨터 시스템의 '버스 아키텍처' 형성 -> 컴퓨터 구조의 중요한 부분
- STM 32에서 사용하는 버스 = ARM에서 설계한 버스 (AMBA)
- 데이터 버스
    - CPU와 메모리, 그리고 다른 장치 사이에 데이터 전송하는데 활용
    - 데이터 버스의 비트수 = 한 번에 전송할 수 있는 데이터의 양 결정 → 시스템의 성능을 결정함
    - 메모리 칩에서 데이터 핀이 8개면 보통 8비트 메모리
    - 메모리 주소 = Byte Address
        - byte = 8bit
        - half word = 16 bit
        - word = 32bit
- 주소 버스
    - CPU가 메모리 또는 입출력 장치의 특정 위치를 식별할 수 있도록 신호 전달
    - 메모리 칩에서 어드레스 핀이 19개라면 2^19 = 512KB 용량이 된다 (아닌 경우도 존재, DataSheet 확인 필요)
- 제어 버스
    - 메모리와 입출력 장치를 제어하기 위해 사용하는 신호 전달
    - 칩 선택 → 메모리 칩에서 CS 핀 활용
    - 데이터 읽고 쓰기 → OE 핀 활용 but, WE 핀에 high가 들어가는 경우 쓰기가 안됨
    - 인터럽트 존재

c.f ) 주소 (address)  = BASE + OFFSET

- 임베디드 시스템은 x86 PC용으로 설계된 것과는 다른 버스 기술 사용
- 임베디드 디바이스는 칩 내부에 있는 온칩 버스를 사용하여 다양한 주변 장치를 CPU 코어와 상호 연결 가능
- 버스에 연결된 장치
    - 프로세서 코어는 동일한 버스에서 다른 디바이스와 데이터 전송을 시작할 수있는 논리 디바이스인 버스 마스터
    - 주변 장치는 버스 마스터 장치의 전송 요청에만 응답할 수 있는 논리 장치인 버스 슬레이브에 속함.

### 프로그램 실행과 버스 동작과의 관계

```c
int main() {
	int a, b, c;
	c = a + b;
}
```

위 코드 실행 과정

1. 컴파일러와 링커에 의해 기계어 변환
2. 기계어 코드를 코드 메모리에 저장
3. 프로세서는 PRE-FETCH라는 방법으로 버스를 통해 기계어 코드를 코드 메모리로부터 읽음
4. 프로세서는 해당 코드를 해석하고 실행
5. 해석된 코드가 버스 동작을 요구하는 경우 버스 신호 발생하며 일련의 동작 수행

### 폰노이만 아키택쳐 vs. 하버드 아키택쳐

- 폰노이만 아키택쳐는 메모리가 하나만 존재하기 때문에 코드와 데이터를 읽는 버스가 하나만 존재
- 하버드 아키택쳐는 코드 메모리와 데이터 메모리가 따로 존재하여 코드와 데이터를 동시에 읽고 쓰기 가능
- 결과적으로 하버드 아키택쳐의 성능이 폰노이만 아키택쳐보다 성능이 좋음

### 주요 버스 신호 종류

- 어드레스 버스 신호
- 데이터 버스 신호
- 읽고 쓰기 버스 신호
- 칩셀렉터 제어 신호
- 버스 클럭 신호

### 버스 신호의 네이밍 규칙

- HIGH ACTIVE 신호
    - 정의 : HIGH일때 의미가 있는 신호
    - ex ) SIZ0, FC3
- LOW ACTIVE 신호
    - 정의 : LOW일때 의미가 있는 신호
    - 표기법 : 신호명 앞에 / 를 붙인다.
    - ex ) /CS, /WR, /AS, INT*, nRESET, ACK, BREQ#

c.f ) 신호가 들어가는 것 = ASSERT

### 버스의 세부 신호

- CLKOUT 신호 : 버스 클럭(기준 신호)
- SIZx 신호 : 전송의 크기를 나타냄
- R/W 신호 : 읽기 / 쓰기 제어
- A31-0(어드레스 버스) : 주소 버스
- AS 신호 : 어드레스 스트로브
- D31-0 (데이터 버스) : 데이터 버스
- DS 신호 : 데이터 스트로브
- DSACK1-0 신호 : 버스사이클 터미네이터
- /CS 신호 : 칩 셀렉트

### 어드레스 디코딩

- 일종의 맵핑 과정
- 어드레스 : 프로세서가 메모리나 입출력 장치의 정보를 읽거나 쓰려할 때  필요한 장치의 정확한 위치
- 실제로 모든 메모리나 장치가 각기 다른 어드레스를 갖고 있지 않음
- 어드레스 버스에 입력된 상위 어드레스 값에 따라 디코더가 어느 장치를 선택할지 결정
- 이 방식으로 프로세서는 필요한 장치에 직접 접근

### 메모리 맵

- SoC는 메모리 컨트롤러라고 하는 장치를 내장하고 있음
- 이 컨트롤러의 주 기능 중 하나가 /CS 신호를 만들어 내는 어드레스 디코더 기능
- 메모리 맵 → 시스템 주소 공간이 어떻게 메모리와 기타 장치에 매핑되는지 설명
- 임베디드 시스템의 주소 공간은 MMIO로 구성되어 있다.

### 메모리 컨트롤러

- 중앙 처리 장치와 메모리 간 데이터 흐름을 관리하는 HW

### 메모리 계층구조

- 레지스터
    - CPU 내부 위치, 가장 빠른 메모리 유형
    - 레지스터를 활용하여 인스트럭션, 메모리 주소, 데이터를 저장하며, 컴퓨터가 수행하는 작업을 제어
    - 크기가 제한적
- 캐시 메모리
    - 레지스터와 주 메모리 사이에 위치
    - 자주 사용되는 데이터와 명령어를 빠르게 접근하기 위해 사용
    - CPU가 데이터를 찾을 때 레지스터보다는 느리지만, 주 메모리보단 빠름
- 주 메모리 (RAM)
    - 랜덤 액세스 메모리는 컴퓨터가 실행 중인 프로그램의 인스트럭션과 데이터를 저장하는 공간
    - 캐시보다 많은 데이터를 저장할 수 있음
    - 접근 속도 느림
- 보조 메모리 (디스크)
    - 프로그램과 데이터를 영구적으로 저장할 수 있음
    - RAM 보다 데이터 접근하는 속도가 느림

### 메모리 버스

- MCU  내의 버스 시스템은 데이터, 부소, 제어 버스로 분류
- MCU 내부 버스
    - 마이크로컨트롤러의 내부 구성 요소들 간에 데이터 전송하는 통로
    - CPU, 메모리, 주변 장치 등을 연결
    - 이 사이 데이터 흐름 제어
    - MCU 설계에 따라 다양한 속도, 폭, 프로토콜 존재
- 메모리 버스
    - 마이크로컨트롤러 내의 CPU와 메모리 간의 통신을 위한 전용 통로
    - 데이터를 메모리 → CPU or CPU →메모리 전송 역할
    - 메모리 버스 = 주소 버스 + 데이터 버스
    - 주소 버스 : 메모리 위치 저장
    - 데이터 버스 : 해당 위치에서 읽고 쓸 데이터를 전달

### 리틀 엔디언과 빅 엔디언

컴퓨터 시스템의 데이터의 나열 방식 결정하는 방법

- 리틀 엔디언
    - 가장 낮은 주소에 가장 작은 바이트 (LSB)
    - 바이트들이 반대방향으로 저장
    - ex ) 4바이트 0x12345678 → 0x78563412로 저장
- 빅 엔디언
    - 가장 높은 주소에 가장 큰 바이트
    - 정방향 저장
    - ex ) 4바이트 0x12345678 → 0x12345678로 저장

### 캐시 메모리

주 메모리와 CPU간의 속도 차이를 극복하기 위한 빠른 메모리 → 자주 사용되는 데이터나 명령어를  저장해둠

- ex )
    - 프로세스는 집, 주 메모리는 우물
    - 캐시 메모리는 물을 저장할 수 있는 탱크
    - 뭃이 필요할 때마다 우물로 가는 것을 비효율적이기 때문에 탱크에 저장된 물을 사용함

```c
int i = 0;

while (1)
{
	i++;
}
```

위의 코드에서 i를 한번 주 메모리에서 읽어오면 계산한 i의 값을 계속 캐시 메모리에 저장함

but, 캐시 메모리의 용량은 작기 때문에 저장할 수 있는 것이 한정되어 있음

- 시간 참조 원리
    - 최근 참조된 주소의 데이터는 가까운 미래에 다시 참조될 가능성이 높다
- 공간 참조 원리
    - 어떤 주소의 데이터를 참조할 때, 그 주변 주소의 데이터도 곧 참조될 가능성이 높다
- 캐시는 전반적인 성능 향상을 제공하지만 예측 가능한 실행 시간 보장 어려움

### 메모리 맵핑 I/O

MMIO

- 주변장치를 위해 일정한 메모리 주소 공간을 할당하는 방식
- 주 메모리와 같은 주소 공간에 I/O장치를 맵핑
- 일반적인 메모리 접근 방식으로 입출력 연산 수행 가능

## 임베디드 시스템 최적화

### 인라인 어셈블러

- 겉으로는 C언어 함수처럼 보이지만 내부에 어셈블리 코드 사용
- 어셈블리 코드를 대체할 수 있는 방법이 없기 때문에 사용

### 임베디드 시스템 최적화

1. 처리 성능 최적화
    - CPU 성능 최대한으로 끌어올리는 방법
    - 코드 최적화, 병렬처리, 캐시 사용량 최적화 등의 전략 활용
2. 메모리 사용 최적화
    - 메모리 공간의 90% 이상을 프로그램이 사용하는 경우, 업그레이드 할 때 메모리 부족할 수 있음
        
        → 이러한 경우 메모리 사용 최적화 필요
        
    - 메모리 할당과 해제 적절히 관리하여 메모리 누수 방지 전략 활용
3. 에너지 효율 최적화
    - 배터리로 작동하는 임베디드 시스템의 경우 필요
    - 저전력 모드, 절전 모드, 불필요한 하드웨어 컴포넌트 비활성화 등의 전략 활용

### 임베디드 시스템 성능 최적화

- 적절한 하드웨어 선택
    - 프로젝트 시작 전 선택 중요
- 코드 최적화
    - 불필요한 반복 최소화, 최적의 자료구조 활용, 불필요한 메모리 할당 피하기
    - 컴파일러 활용 최적화 가능
- 멀티스레딩과 병렬 처리
    - 병렬 처리를 활용하여 작업 분산
    - 멀티스레딩, 멀티 프로세싱 활용
- 실시간 운영 체제의 활용
    - RTOS를 사용하여 작업의 우선순위를 정하면 시스템 자원을 효과적으로 관리하여 성능 향상
- 예측 및 캐싱
    - 자주 사용하는 데이터나 계산 결과를 캐시에 저장하여 빠르게 접근
    - 미리 예측하여 필요 연산을 미리 수행하는 방법도 유용

### 인라인 함수

C에서 함수 호출 오버헤드를 줄이기 위한 기능

이를 통해 프로그램 실행 시간 단축, But 프로그램 크기 증가

* 루프 내에서 반복적으로 호출되는 작은 함수인 경우는 인라인 함수로 만드는 것 유용

But, 무조건 인라인 함수를 활용하는 것이 좋은 방법은 아님

### 테이블 룩업

미리 계산된 데이터를 저장하고 이를 다시 활용 → 계산량 감소, 속도 증가

### 전역 변수의 사용

일단 전역변수 사용량은 상황에 맞게 하는 것이 좋다.

- 장점
    - 프로그램 전반에 걸쳐 접근 가능
    - 속도 향상
    - 메모리 효율 상승
    - 상태 유지
- 단점
    - 코드의 유지 및 디버깅의 어려움
    - 변수 이름 충돌
    - 재사용성 간소
    - 병렬 처리 문제

### 고정 소수점 연산

ARM 프로세서는 실수 연산 X → 수학 라이브러리에 의존 (soft float) → 성능 저하

CORTEX 프로세서도 실수 연산 X, But 부동소수점 연산기를 내장한 프로세서 존재 (hard float)
→ CORTEX-M4 이상의 경우

### ROM 사용량 줄이기

- 불필요한 코드 제거
- 코드 재사용
- 컴파일러 최적화 옵션 사용
- 상수 데이터 및 초기화 데이터를 ROM에 저장
    - 전역 변수 작성 시
        
        `int a = 1;`  → .data / .text 중복하여 저장됨
        
        `const int a = 1;` → .text 에만 저장
        
- 불필요한 데이터 제거
- 라이브러리에서 필요하지 않은 기능 제거 or 최소한의 라이브러리만 사용
- 크기 최적화를 위한 라이브러리 선택

### RAM 사용량 줄이기

- 정적 할당 사용하기
    - 동적 메모리 사용 시 메모리 누수 발생 가능성 상승
- 메모리 풀 사용
- 작은 스택 사용
    - 단점 : 배열 같은 경우를 사용해도 되는지 고민하는 시간 증가
    - But, 다른 용도로 활용할 메모리 용량이 제한되므로 작은 스택 사용 권장
- 동적 할당 계획이 없다면, 힙 영역 자체를 생성하지 않는 방법

### 정렬과 구조체

```c
struct {
	char a;
	int b;
	char c;
	short d;
}
```

위의 경우 12 바이트의 메모리 필요

```c
struct {
	char a;
	char c;
	short d;
	int b;
}
```

다시 정렬하면 8바이트의 메모리 필요

- 모든 패딩을 제거하는 키워드 `_packed` 사용 하는 경우
    - 속도가 느려지고 비효율적임
    - 하지만 속도보다 공간이 훨씬 중요한 경우 + 재배열로 패딩을 줄일 수 없는 경우만 활용