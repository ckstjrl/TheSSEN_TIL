# 임베디드 소프트웨어 개발 기본 day01

날짜: 2026년 1월 26일

## 임베디드 시스템 개론



### 정의

- 임베디드 시스템은 특정한 목적을 수행하기 위한 디자인된 컴퓨터 시스템
- 하드웨어와 소프트웨어의 결합 시스템

“임베디드란 특정한 목적을 위해 하드웨어와 소프트웨어의 결합 시스템이다”

### 구성

- 하드웨어 : CPU, 메모리, 입출력 인터페이스
- 소프트웨어 : 특정 장치를 제어하거나, 데이터를 처리하거나, 사용자 인터페이스 제공
- RTOS : 작업의 일관성과 정확성을 보장하며, 특정 시간 제약 내에서 작업을 완료하도록 보장하는데 중요한 역할

### 하드웨어

- 메모리
    - 시스템이 실행되는 동안 데이터 (변수)(데이터 메모리)와 명령어 (코드)(코드 메모리)를 저장하는 공간
    - RAM, ROM 두 가지 유형 존재
    - RAM - 임시 데이터 저장, 시스템 종료시 휘발됨(지워진다라는 표현보다는 유효성이 사라진다라는 표현이 더 맞는 말) → 데이터, 명령어 둘 다 저장 가능
    - ROM - 비휘발성, 보통 시스템의 부팅 코드나 필수적인 설정 값 저장 → READ ONLY
- I/O (입출력) 장치
    - 입출력 장치는 시스템과 외부 세계와 상호 작용
    - ex. 센서, 스위치, 디스플레이, 통신 포트
- 기타 하드웨어 구성요소
    - 여러가지 보조 장치와 부가적인 하드웨어 요소 존재
    - PAL, PLD, 외부 메모리 카드, 네트워크 인터페이스, GPS 모듈, 카메라, 사운드 장치 등 다양한 형태 존재

### 시스템 개발 환경 - 교차 개발 환경 (Cross development Environment)

호스트 시스템

→

- ICE or JTAG cable(산업 표준) → 개발 장비 없이도 개발 가능
- Serial cable
- Ethernet cable

→

타켓 시스템

### 임베디드 시스템 운영 체제

- 운영체제가 포함되어 있지 않은 임베디드 시스템 → 펌웨어(bare metal program)
- 운영체제가 포함되어 있는 임베디드 시스템 → 임베디드 리눅스, RTOS (선호 운영체제)
- 운영체제는 주변 장치, 메모리, 처리시간 등 시스템 리소스 관리
- RTOS, 리눅스 두가지 주요 범주로 나눔
- RTOS는 이벤트에 보장된 응답 시간을 제공
- 리눅스는 실시간이 아닌 대규모 어플리케이션을 관리하기 위해 메모리 관리 장치 필요, 보조 스토리지 사용

### 실시간 임베디드 시스템

- 리얼타임 시스템
    - 정해진 시간 내에 임무를 수행하는 시스템
    - 예)
        - 10초안에 커피 자판기에서 커피가 나옵니다 → 10초 안에 나오면 리얼타임 시스템
        - 1초만에 커피 자판기에서 커피가 나옵니다 → 1초안에 안나오면 리얼타임 시스템
- 소프트 리얼타임 시스템
    - 가능한 빠르게 임무를 수행하지만 반드시 정해진 시간 내에 수행할 필요는 없다. (timeout 이어도 계속 수행)
    - 예) 동영상 플레이어
- 하드 리얼타임 시스템
    - 어떤 사건이 발생했을 때 정확히 동작하고 반드시 정해진 시간 내 그 임무를 마쳐야 한다.
    - 예) 인공위성, 미사일 제어, 원자력 발전 제어

“반드시 정해진 요건에 맞춰 작동하면 하드 리얼타임, 정해진 요건과 살짝이라도 빗나가면 소프트 리얼타임”

### 실시간 운영체제

- 최소한의 지연 시간 : RTOS는 외부 이벤트에 대해 가능한 빠르게 반응. 이를 위해 지연 시간을 최소화하는 매커니즘 구현
- 메모리 관리 : 효율적으로 관리, 메모리 누수 방지
- 대표적인 예 - Free RTOS, RTLinux, VxWorks

---

---

## 임베디드 시스템 설계



### 임베디드 시스템 제작 과정

- 공학적 절차를 따르는 복잡한 과정
- 요구사항 정의
- 설계
- 구현

### 개발 환경

- 디버깅 도구
    - 오실로스코프, JTAG 디버거, 로직분석기 등 사용
- 비전 관리 시스템
    - 소스 코드 변경 사항 추적, 여러 개발자 간의 협업 용이
    - Git, SVN등을 사용
- 자동화 도구
    - 빌드 자동화 도구 CMake

### JTAG과 디버깅 도구

- 디버깅 도구 - 프로그래밍에서 오류를 찾고 수정하는 과정을 돕는 소프트웨어
- JTAG을 통해 디버깅 인터페이스에 접근하여 디버깅

### LED 디버깅

`printf`가 동작하기 전에는 LED가 디버깅에 도움을 준다

→ 스타트 코드를 디버깅할 때 LED를 활용

### 74시리즈

- 디지털 전자 회로 → 논리회로, 카운터, 플립플롭, 멀티 플렉서, 티코더 등

### ROM에서 실행하기

- 리셋 후 프로세서는 0x0에서 명결을 가져오기 시작
- 임베디드 시스템에서 초기에는 0x0 주소에 ROM이 있어야 함
- 메모리 맵 주소 0에 있는 ROM에 어플리케이션을 배치
    
    다음 어플리케이션은 첫번째 명령어를 실행할 때 실제 진입점으로 분기할 수 있음
    
- But, 이 레이아웃 (XIP : execute in place)에는 단점 존재 → 코드가 들어가는 곳에서 실행도 같이 진행

### 소프트웨어의 논리적인 메모리 구조

- code가 들어가는 영영 → RAM / text
- 초기화 안된 전역변수 or 0으로 초기화된 전역변수 → RAM / bss(ZI) → start code에서 bss에 있는 전역 변수를 0으로 초기화 시킴
- 초기화된 전역변수 → RAM / data(RW)
- const → RAM / rodata
- 지역변수 → RAM / stack
- 초기화 안된 정적 지역변수 → RAM / bss(ZI)
- 초기화 된 정적 지역변수 → RAM / data(RW)
    
    c.f ) 정적 지역변수를 선언하면 디버깅할 떄 문제점을 쉽게 찾을 수 있다 는 장점이 있다. + 함수 외부 접근을 강제 차단
    
- `malloc();` → RAM / heaq
    
    c.f )  힙과 스택의 공통점 → 데이터 저장 삭제
    
    힙 메모리는 데이터 할당 제거가 수동 / 스택은 메모리 할당 제거가 자동
    
- 문자열 → RAM / text

### 링커 스크립트

RAM의 주소, 영역 등 전체적인 구조를 저장하는 것

- 링커는 입력파일을 합쳐서 하나의 출력파일을 만든다.

### 레지스터 구조

레지스터 = 저장소 → 자료를 비트로 보관하는 아주 빠른 기억 장소

1. CPU 레지스터
    - CPU 안에 있는 레지스터
2. HW 레지스터
    - CPU 외부에 있는 레지스터

### 임베디드 소프트웨어에서 자주 사용하는 비트 연산

- `>>` 왼쪽으로 밀어내는 연산 ⇒ 나누기
- `<<` 오른쪽으로 밀어내는 연산 ⇒ 곱하기
- `&=~` 선택된 비트 패턴 클리어 (zero fill 마스킹)
    
    ```smalltalk
    c = 0xFFFFFFFF
    
    // 15번 비트를 지워라
    c = c & ~0x8000
    c = c & ~(1 << 15)
    
    //22번 비트를 지워라
    c = c & ~(1 << 22)
    
    // 23번 22번 비트 지워라
    c = c & ~(3 << 22)
    
    // 31번 20번 비트 지워라
    c = c & ~((1 << 31) | (1 << 20))
    ```
    
- `|=` 세트 (기록)
    
    ```smalltalk
    c = 0x00000000
    
    // 15번 비트를 세트
    c = c | 0x8000
    c = c | (1 << 15)
    
    //22번 비트를 세트
    c = c | (1 << 22)
    
    // 23번 22번 비트 세트
    c = c | (3 << 22)
    
    // 31번 20번 비트 세트
    c = c | ((1 << 31) | (1 << 20))
    ```
    
- 레지스터 값 변경
    
    ```c
    //case 1, 22 23 주소를 0 1 로 변경하는 것이 최종 목표
    rGPIOx_MODER = rGPIOx_MODER &~ (3 << 22);
    rGPIOx_MODER = rGPIOx_MODER | (1 << 23);
    // 이렇게 작성하게 되면 의도치 않은 0 0과정을 거친 후 0 1로 간다...
    
    //case 2
    rGPIOx_MODER = rGPIOx_MODER &~ (1 << 22);
    rGPIOx_MODER = rGPIOx_MODER | (1 << 23);
    
    //case 3
    rGPIOx_MODER = (rGPIOx_MODER &~ (3 << 22)) | (1 << 23);
    // 이 코드만이 정답이다!!!!!!
    // 다른 코드는 버그를 발생시킬 수 있지만 원하는 바를 한번에 연산하므로 이것이 맞다
    // 임의의 연속된 2 비트 이상을 변경하고자 할 때 사용
    ```
    

### 메모리 3 종류

- 플래시 ROM
- DRAM
- SRAM

### 주변 장치 = Peripherals 혹은 I/O

- 오프칩인 다른 장치나 센서에 연결하여 칩의 입출력 기능 수행
- ARM 기반 시스템에서의 주변 장치는 메모리 매핑되며(MMIO),
프로그래밍 인터페이스는 메모리 주소가 지정된 레지스터 집합
- 종류
    - 입력
    - 출력
    - 통신
    - 저장장치
    - 전원장치

### MCU vs. CPU

MCU (Micro Controller Unit)

: CPU 가 반드시 포함

: Peripherals 이 반드시 포함

: 메모리는 옵션 (하지만, 포함되어 있는 경우가 대부분)

→ MCU 대신 CPU를 사용하는 경우 Peripherals을 따로 장착해야 하므로 복잡 & 가격 경쟁력 낮아짐.

### MCU 선택 시 고려해야 하는 것

1. 처리 능력
    - 주파수(MHz), CPU 유형, 워드 크기 (비트), 부동소수점 유닛 유무 등 포함
2. 메모리 용량
    - 충분한 RAM 및 Flash 메모리 용량
3. 통신 인터페이스
    - CAN, USB, Ethernet 등
4. 전력 소모
    - 배터리를 사용하는 휴대용 장치인 경우 전력 소모량 중요
5. 입출력 포트
    - 시스템이 필요로 하는 충분한 입출력 포트 있어야 함
6. 공급연속성
    - 공급 업체가 계속해서 공급해줄 수 있는지 확인 필수
7. 소프트웨어 및 하드웨어 지원
    - MCU가 제공하는 개발도구, 소프트웨어 라이브러리, 하드웨어 테스트 및 디버깅 도구 사용 적합성, 필요 부합성 확인
8. 임베디드 보안
    - 보안에 민감한 정보를 처리하거나 통신하거나 저장하는 경우 하드웨어 보안 기능 (암호화 엔진, 보안키 저장 등) 확인

### OS 선택할 때 고려해야 하는 것

1. 시스템 요구 사항
2. 실시간 처리
3. 유지 보수와 지원
4. 비용

### 펌웨어, RTOS, 리눅스

- 펌웨어, RTOS, 리눅스가 임베디드 시스템의 대표적인 소프트웨어 유형
- 특정 목적과 요구사항에 따라 선택 가능, 상황에 따라 각각이나 함께 사용 가능
- 펌웨어(Firmware)
    - 하드웨어 제어를 위한 내장형 소프트웨어
    - 장점 (활용 part)
        - 속도(성능)이 중요한 경우
        - 복잡도 낮은 경우
        - 멀티테스크가 필요 없는 경우
    - 단점
        - 모든 기능을 개발자가 이식해야 함. (PORTING)
        - 버그가 발생할 확률 높음
- RTOS (Real-Time OS)
    - 장접
        - 멀티테스킹
        - 멀티테스킹을 사용하지 않아도 유일하게 장점이 되는 경우는 모듈화 하는 경우
    - 단점
        - 모든 기능이 필요하면 개발자가 이식해야 함
- 리눅스 (Linux)
    - 장점
        - 안정적인 네트워크
        - open source 존재
    - 단점
        - CPU 고성능
        - 많은 양의 메모리 필요
        - 숙련된 개발자 필요로 함 (리눅스 + 하드웨어) → 장벽이 높음

---

---

## STM32 간단 실습



```c
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  uint32_t odr;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR; // HW 레지스터

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
}

void HAL_GPIO_TogglePin2(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* get current Output Data Register value */
  GPIOx->ODR = GPIOx->ODR ^ GPIO_Pin;
}

// main.c
int main{
	while (1)
  {
		HAL_GPIO_TogglePin2(LD3_GPIO_Port, (0x2000|0x4000));
		//HAL_GPIO_TogglePin(LD3_GPIO_Port, (LD3_Pin|LD4_Pin));
		// 두 코드 동일
		HAL_Delay(250); // ms
  }
}
```
---
---

## 버스와 메모리


### 버스
- 버스 : 컴퓨터 내부에서 데이터, 주소, 제어 신호를 전달하는 주요 통신 경로
- 종류
    - 데이터 버스
    - 주소 버스
    - 제어 버스
- 3가지 종류를 합쳐서 컴퓨터 시스템의 '버스 아키텍처' 형성 -> 컴퓨터 구조의 중요한 부분
- STM 32에서 사용하는 버스 = ARM에서 설계한 버스 (AMBA)
- 데이터 버스
    - CPU와 메모리, 그리고 다른 장치 사이에 데이터 전송하는데 활용
    - 데이터 버스의 비트수 = 한 번에 전송할 수 있는 데이터의 양 결정
