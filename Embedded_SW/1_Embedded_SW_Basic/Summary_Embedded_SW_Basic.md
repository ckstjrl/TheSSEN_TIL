# 임베디드 소프트웨어 기초 핵심 요약

---

## 1. 임베디드 시스템 개요

### 정의
> **임베디드 시스템** = 특정 목적을 위해 설계된 **하드웨어 + 소프트웨어 결합 시스템**

### 구성 요소
- **하드웨어**: CPU, 메모리(RAM/ROM), 입출력 인터페이스
- **소프트웨어**: 장치 제어, 데이터 처리, UI 제공
- **RTOS**: 시간 제약 내 작업 완료 보장

---

## 2. 메모리 종류

| 구분 | 특징 |
|------|------|
| RAM | 임시 저장, 전원 꺼지면 유효성 소멸, 데이터/명령어 저장 가능 |
| ROM | 비휘발성, 부팅 코드/필수 설정값 저장, READ ONLY |
| Flash ROM | 비휘발성 저장, 코드 저장 용도 |
| DRAM | 주 메모리로 사용, 느리지만 용량 큼 |
| SRAM | 캐시 용도, 빠름 |

### 소프트웨어 메모리 구조 (논리적)

```
┌─────────────┐
│   Stack     │ ← 지역변수, 자동 할당/해제
├─────────────┤
│   Heap      │ ← malloc(), 수동 할당/해제
├─────────────┤
│   .bss(ZI)  │ ← 초기화 안된 전역/정적 변수 (0으로 초기화)
├─────────────┤
│   .data(RW) │ ← 초기화된 전역/정적 변수
├─────────────┤
│   .text     │ ← 코드, 문자열, const 변수
└─────────────┘
```

- `int a = 1;` → `.data`와 `.text` 중복 저장 (ROM + RAM 모두 차지)
- `const int a = 1;` → `.text`에만 저장 (ROM 절약)

---

## 3. 버스 시스템

### 버스의 3가지 종류

| 버스 | 역할 |
|------|------|
| 데이터 버스 | CPU ↔ 메모리 간 실제 데이터 전송 |
| 주소 버스 | 접근할 메모리/장치의 위치(주소) 전달 |
| 제어 버스 | 읽기/쓰기, 칩 선택 등 제어 신호 전달 |

- STM32 사용 버스 = **AMBA** (ARM 설계)
- 주소 = **BASE + OFFSET**
- 어드레스 핀 19개 → 2¹⁹ = **512KB** 주소 공간

### 폰노이만 vs 하버드 아키텍처

| 구분 | 폰노이만 | 하버드 |
|------|---------|--------|
| 메모리 | 코드+데이터 공유 | 코드/데이터 분리 |
| 버스 | 1개 | 2개 |
| 성능 | 낮음 | 높음 (동시 접근 가능) |

### 버스 신호 네이밍 규칙
- **HIGH ACTIVE**: HIGH일 때 의미 있는 신호 (예: SIZ0, FC3)
- **LOW ACTIVE**: LOW일 때 의미 있는 신호, 앞에 `/` 또는 `n`, `#` 붙임 (예: /CS, nRESET)

### 어드레스 디코딩
- 상위 어드레스 값으로 디코더가 어느 장치를 선택할지 결정
- **메모리 맵**: 시스템 주소 공간이 메모리/장치에 어떻게 매핑되는지 정의
- 임베디드 시스템은 **MMIO(Memory Mapped I/O)** 방식 사용

---

## 4. 메모리 계층구조

```
레지스터 (가장 빠름, 가장 작음)
    ↓
캐시 메모리 (L1/L2)
    ↓
주 메모리 (RAM)
    ↓
보조 메모리 (디스크, 가장 느림, 가장 큼)
```

### 캐시 메모리 동작 원리
- **시간 참조 원리**: 최근 참조된 데이터는 곧 다시 참조될 가능성이 높다
- **공간 참조 원리**: 참조한 주소 주변 데이터도 곧 참조될 가능성이 높다
- ⚠️ 캐시는 성능 향상에 도움이 되지만 **예측 가능한 실행 시간 보장이 어려움**

### 엔디언(Endian)
- **리틀 엔디언**: LSB를 낮은 주소에 저장 → `0x12345678` → `78 56 34 12`
- **빅 엔디언**: MSB를 낮은 주소에 저장 → `0x12345678` → `12 34 56 78`

---

## 5. 실시간 시스템 (Real-Time System)

| 구분 | 설명 | 예시 |
|------|------|------|
| 하드 리얼타임 | 반드시 정해진 시간 내 완료, 초과 시 시스템 실패 | 미사일 제어, 원자력 발전 |
| 소프트 리얼타임 | 가능한 빠르게 수행, 초과해도 계속 동작 | 동영상 플레이어 |

### RTOS 특징
- 최소 지연 시간 보장
- 효율적인 메모리 관리, 누수 방지
- 대표 예: **FreeRTOS, RTLinux, VxWorks**

---

## 6. 소프트웨어 유형 비교

| 구분 | 장점 | 단점 |
|------|------|------|
| **펌웨어** | 빠른 속도, 단순 구조 | 모든 기능 직접 구현, 버그 위험 높음 |
| **RTOS** | 멀티태스킹, 모듈화 가능 | 필요 기능 직접 이식 필요 |
| **Linux** | 안정적 네트워크, 오픈소스 | 고성능 CPU, 대용량 메모리, 숙련 개발자 필요 |

---

## 7. MCU 선택 시 고려 사항

1. **처리 능력**: 주파수(MHz), CPU 유형, 워드 크기, FPU 유무
2. **메모리 용량**: RAM + Flash 용량
3. **통신 인터페이스**: CAN, USB, Ethernet 등
4. **전력 소모**: 배터리 제품의 경우 특히 중요
5. **입출력 포트**: 필요한 포트 수 충족 여부
6. **공급 연속성**: 장기 공급 보장 여부
7. **소프트웨어/HW 지원**: 개발 도구, 라이브러리 등
8. **임베디드 보안**: 암호화 엔진, 보안키 저장 기능 등

### MCU vs CPU
- **MCU** = CPU + Peripherals + 메모리(옵션) → 단일 칩으로 완결
- **CPU만 사용** → Peripherals 별도 장착 필요 → 복잡, 비용 증가

---

## 8. 비트 연산 (레지스터 제어 핵심)

```c
// 특정 비트 클리어 (0으로 만들기)
reg &= ~(1 << n);          // n번 비트 클리어
reg &= ~(3 << 22);         // 22,23번 비트 클리어

// 특정 비트 세트 (1로 만들기)
reg |= (1 << n);           // n번 비트 세트
reg |= (3 << 22);          // 22,23번 비트 세트

// ✅ 연속된 비트를 특정 값으로 변경할 때 올바른 방법
reg = (reg & ~(3 << 22)) | (1 << 23);  // 클리어 후 세트를 한 줄에!
// ❌ 두 줄로 나누면 중간 상태(00)가 발생하여 버그 유발 가능
```

---

## 9. 임베디드 시스템 최적화

### ROM 사용량 줄이기
- 불필요한 코드 제거, 코드 재사용
- `const` 키워드 적극 활용 (`.data` → `.text`로 이동)
- 컴파일러 최적화 옵션 사용
- 최소한의 라이브러리만 사용

### RAM 사용량 줄이기
- **정적 할당** 선호 (동적 할당 시 메모리 누수 위험)
- **메모리 풀** 사용
- 작은 스택 사용 권장
- 힙 영역 자체를 생성하지 않는 방법도 고려

### 구조체 메모리 정렬 최적화

```c
// ❌ 비효율적 (12바이트)
struct { char a; int b; char c; short d; }

// ✅ 효율적 (8바이트) - 작은 타입끼리 묶어서 배치
struct { char a; char c; short d; int b; }
```
- `__packed` 키워드: 모든 패딩 제거 가능하나 **속도 저하** 발생 → 공간이 매우 중요한 경우에만 사용

### 성능 최적화 기법
| 기법 | 설명 |
|------|------|
| 인라인 함수 | 함수 호출 오버헤드 제거, 코드 크기는 증가 |
| 테이블 룩업 | 미리 계산된 값을 저장해 연산 속도 향상 |
| 고정 소수점 연산 | FPU 없는 MCU에서 실수 연산 대체 |
| 캐시 최적화 | 자주 사용 데이터를 캐시 친화적으로 접근 |
| RTOS 활용 | 작업 우선순위 설정으로 자원 효율적 관리 |

---

## 10. 개발 환경

### 교차 개발 환경 (Cross Development Environment)
- **호스트 시스템** (PC)에서 개발 → **타겟 시스템** (임베디드 보드)에서 실행
- 연결 방법: **JTAG**(산업 표준), Serial, Ethernet

### 디버깅 도구
- JTAG 디버거, 오실로스코프, 로직 분석기
- `printf` 사용 불가 시 **LED 디버깅** 활용 (스타트 코드 디버깅 시 유용)
- 버전 관리: Git, SVN
- 빌드 자동화: CMake

### 링커 스크립트
- RAM의 주소, 영역 등 전체 메모리 구조 정의
- 링커가 입력 파일들을 합쳐 하나의 출력 파일 생성

---

> 💡 **핵심 한 줄 요약**
> 임베디드 개발 = 제한된 자원(메모리, 전력, 성능) 안에서 실시간으로 동작하는 최적화된 시스템을 만드는 것