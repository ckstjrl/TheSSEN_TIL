# 면접 준비

예상 질문 & 모범 답안 형식

---

## 질문 1 
폰노이만 아키텍쳐와 하버드 아키텍쳐의 차이점을 설명하고, 임베디드 시스템에서 어떤 아키텍처가 더 적합한지 말씀해주세요.
---

폰노이만 아키텍쳐는 코드와 데이터를 하나의 메모리에 저장하고 하나의 버스를 공유하여 사용합니다.

반면 하버드 아키텍쳐의 경우 코드 메모리와 데이터 메모리가 분리되어 있고 각 버스가 존재하여 동시에 읽고 쓰기가 가능합니다.

결과적으로 하버드 아키텍쳐가 성능면에서 우수합니다. 임베디드 시스템의 경우 실시간 처리와 빠른 응답이 중요하기 때문에 하버드 아키텍쳐를 택하는 경우가 많습니다.

다만 트레이드 오프로 하드웨어의 복잡성이 올라가는 단점이 존재합니다.

---

## 질문 2
### 하드 리얼타임과 소프트 리얼타임의 차이를 설명하고 각각의 예시를 들어주세요.
---

하드 리얼타임 시스템은 반드시 정해진 시간 내에 임무를 완료해야 하며, 시간초과가 발생하면 시스템 자체가 실패한 것으로 간주됩니다.

미사일 제어, 원자력 발전소 제어 시스템 등 실시간 응답이 중요한 시스템이 대표적입니다.

소프트 리얼타임 시스템은 가능한 빠르게 임무를 수행하지만, 정해진 시간이 초과하더라도 시스템이 계속 동작하는 구조입니다.

동영상 플레이어 같이 프레임이 늦게 출력되어도 재생 자체가 중단되지 않는 경우가 소프트 리얼타임에 해당합니다.

임베디드 시스템 설계 시 어느 수준의 리얼타임이 요구되는지 파악하는 것이 OS 및 아키텍쳐 선택에 중요합니다.

---

## 질문 3
### 펌웨어, RTOS, Linux 중 프로젝트에 맞는 소프트웨어 플랫폼을 어떻게 선택하시겠습니까?
---

먼저 시스템의 복잡도와 요구사항을 기준으로 판단할 것입니다.

기능이 단순하고 멀티태스킹이 필요 없으며 빠른 응답속도가 중요한 경우 펌웨어가 적합합니다.
다만, 모든 기능을 직접 구현해야 하기때문에 위험성이 조금 있다 생각합니다.

멀티태스킹이 필요하더나 코드를 모듈화하여 유지보수성을 높이려는 경우 RTOS가 적합합니다.

마지막으로 안정적인 네트워크 스택이나 다양한 오픈소스 생태계를 활용할 경우에는 Linux가 적합합니다.
다만 Linux를 사용하는 경우 고성능의 CPU와 대용량의 메모리가 필요하고 개발자의 역량 수준이 높아야한다는 점이 고려 사항입니다.

---

## 질문 4 
### 임베디드 시스템에서 레지스터의 특정 비트를 안전하게 변경하는 방법을 설명해 주세요.
---

레지스터의 연속된 비트를 변경할 때는 반드시 클리어와 세트를 하나의 연산으로 처리해야 합니다.

클리어와 세트가 원자적으로 동작해 중간 상태 없이 원하는 값으로 정확하게 유지해야 합니다.

---

## 질문 5
### 소프트웨어 메모리 구조에서 .text, .data, .bss 영역의 차이를 설명하고, `int a = 1;` 과 `const int a = 1;`이 메모리에 어떻게 다르게 저장되는지 말씀해주세요.
---

.text 영역은 실행 코드의 상수 데이터가 저장되는 ROM입니다.

.data 영역은 초기화된 전역변수가 저장되며 RAM, ROM 모두 존재 합니다. ROM에는 초기값들이 저장되어 있으며, 부팅 시 RAM으로 복사되어 실행 중에 사용합니다.

.bss 영역은 초기화되지 않은 전역변수가 저장되며 스타트 코드에서 자동으로 0으로 초기화됩니다.

`int a = 1;`로 변수를 선언하게 되면 초기값이 ROM에 저장되고 RAM에 복사되어 두 곳의 메모리를 사용합니다.

`const int a = 1;`로 변수를 선언하면 .text 영역에만 저장되어 ROM만 사용하므로 RAM의 공간을 절약할 수 있습니다.

이 두 가지는 메모리가 제한된 임베디드 환경에서 중요한 최적화 포인트가 된다고 생각합니다.

---

## 질문 6 
### 임베디드 시스템에서 구조체 멤버 순서가 메모리 사용량에 영향을 미치는 이유를 설명하고 최적화 방법을 말씀해주세요.
---

C 컴파일러는 구조체 멤버를 각 타입의 크기에 맞게 정렬하기 위해 패딩 바이트를 삽입합니다.

예를 들어 char, int, char, short 순서로 선언하면 int 앞뒤에 패딩이 붙어 12바이트가 되지만, char, char, short, int 순서로 재배치하면 패딩 없이 8바이트로 줄일 수 있습니다.

최적화 방법은 크기가 큰 타입부터, 또는 같은 크기의 타입끼리 묶어서 배치하는 것입니다.

__packed 키워드로 패딩을 강제로 제거할 수도 있지만 메모리 접근 속도가 느려지므로, 공간이 매우 부족한 경우에만 사용하는 것이 권장됩니다.

---

## 질문 7 
### 캐시 메모리의 동작 원리와 임베디드 시스템에서 캐시 사용 시 주의해야 할 점을 설명해주세요.
---

캐시 메모리는 주 메모리와 CPU 사이의 속도 차이를 줄이기 위해 자주 사용되는 데이터를 임시 저장하는 고속 메모리입니다.

동작원리는 시간 참조 원리, 공간 참조 원리에 기반합니다.

시간 참조 원리는 최근에 접근한 데이터는 다시 접근할 가능성이 높다는 것이고,

동작 참조 원리는 특정 주소에 접근하면 그 주변 주소도 접근할 가능성이 높다고 보는 것입니다.

임베디드 시스템, 특히 하드 리얼 타임 시스템의 경우 캐시 히트/미스 여부에 따라 실행 시간이 달라지기 때문에 실행 시간 보장이 어렵다는 단점이 존재합니다.

따라서 안전이 중요한 시스템에서는 캐시를 비활성화하거나 별도로 관리하는 경우가 존재합니다.